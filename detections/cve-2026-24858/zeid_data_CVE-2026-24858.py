#!/usr/bin/env python3
"""zeid_data_CVE-2026-24858 — Fortinet FortiCloud SSO abuse detector (defensive-only)

Parses FortiOS/FortiGate-style event logs (key=value pairs) and flags patterns
consistent with FortiCloud SSO abuse and post-login persistence actions.

This tool:
  - reads text log files
  - produces JSON findings
  - does NOT exploit anything
  - does NOT modify systems
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Dict, List, Optional

# IOCs from Fortinet PSIRT blog (can change over time). Tunable via CLI flags.
DEFAULT_SSO_USERS = {
    "cloud-noc@mail.io",
    "cloud-init@mail.io",
}
DEFAULT_SUSPICIOUS_ADMIN_NAMES = {
    "audit", "backup", "itadmin", "secadmin", "support"
}
DEFAULT_IP_IOCS = {
    "104.28.244.115",
    "104.28.212.114",
    "37.1.209.19",
    "217.119.139.50",
}

LOGID_ADMIN_LOGIN_SUCCESS = "0100032001"
LOGID_OBJECT_ATTR_CONFIGURED = "0100044547"

KV_RE = re.compile(r'(\b[\w.-]+)=(".*?"|\S+)')
QUOTES_MAP = str.maketrans({
    "“": '"', "”": '"', "„": '"', "’": "'", "‘": "'", "—": "-", "–": "-",
})

def parse_kv_line(line: str) -> Dict[str, str]:
    line = line.translate(QUOTES_MAP).strip()
    out: Dict[str, str] = {}
    for k, v in KV_RE.findall(line):
        v = v.strip()
        if v.startswith('"') and v.endswith('"'):
            v = v[1:-1]
        out[k] = v
    return out

@dataclass
class Finding:
    rule_id: str
    severity: str
    reason: str
    line_no: int
    raw: str
    fields: Dict[str, str]

def is_sso_login(evt: Dict[str, str]) -> bool:
    method = (evt.get("method") or "").lower()
    ui = evt.get("ui") or ""
    status = (evt.get("status") or "").lower()
    action = (evt.get("action") or "").lower()
    logid = evt.get("logid") or ""
    logdesc = (evt.get("logdesc") or "").lower()
    return (
        (logid == LOGID_ADMIN_LOGIN_SUCCESS or "admin login successful" in logdesc)
        and method == "sso"
        and "sso(" in ui.lower()
        and status == "success"
        and action == "login"
    )

def is_local_admin_add(evt: Dict[str, str]) -> bool:
    logid = evt.get("logid") or ""
    cfgpath = (evt.get("cfgpath") or "").lower()
    action = (evt.get("action") or "").lower()
    return (logid == LOGID_OBJECT_ATTR_CONFIGURED and cfgpath == "system.admin" and action == "add") or (
        cfgpath == "system.admin" and action == "add"
    )

def main(argv: Optional[List[str]] = None) -> int:
    p = argparse.ArgumentParser(
        prog="zeid_data_CVE-2026-24858",
        description="Detect FortiCloud SSO abuse patterns for CVE-2026-24858 in Fortinet logs (defensive-only)."
    )
    p.add_argument("--log", action="append", required=True, help="Path to Fortinet syslog/event log file. Repeatable.")
    p.add_argument("--out", default="", help="Write JSON findings to this path (default: stdout).")
    p.add_argument("--extra-sso-user", action="append", default=[], help="Add IOC SSO usernames (repeatable).")
    p.add_argument("--extra-ioc-ip", action="append", default=[], help="Add IOC IPs (repeatable).")
    p.add_argument("--extra-admin-name", action="append", default=[], help="Add suspicious local admin names (repeatable).")
    args = p.parse_args(argv)

    sso_users = set(DEFAULT_SSO_USERS) | set(args.extra_sso_user)
    ip_iocs = set(DEFAULT_IP_IOCS) | set(args.extra_ioc_ip)
    suspicious_admin_names = set(DEFAULT_SUSPICIOUS_ADMIN_NAMES) | set(args.extra_admin_name)

    findings: List[Finding] = []

    for log_path in args.log:
        path = Path(log_path)
        if not path.exists():
            print(f"[!] Missing log file: {path}", file=sys.stderr)
            continue
        with path.open("r", encoding="utf-8", errors="replace") as f:
            for i, raw in enumerate(f, start=1):
                line = raw.rstrip("\n")
                evt = parse_kv_line(line)
                if not evt:
                    continue

                if is_sso_login(evt):
                    user = (evt.get("user") or "").lower()
                    srcip = evt.get("srcip") or ""
                    sev = "high" if (user in sso_users or srcip in ip_iocs) else "medium"
                    reason_bits = ["SSO admin login success"]
                    if user in sso_users:
                        reason_bits.append(f"user IOC match: {user}")
                    if srcip in ip_iocs:
                        reason_bits.append(f"srcip IOC match: {srcip}")
                    findings.append(Finding(
                        rule_id="FORTI_SSO_LOGIN_SUCCESS",
                        severity=sev,
                        reason="; ".join(reason_bits),
                        line_no=i,
                        raw=line,
                        fields=evt,
                    ))

                if is_local_admin_add(evt):
                    cfgobj = (evt.get("cfgobj") or "").lower()
                    user = (evt.get("user") or "").lower()
                    sev = "high" if (cfgobj in suspicious_admin_names or user in sso_users) else "medium"
                    reason_bits = ["Local admin added (system.admin)"]
                    if cfgobj:
                        reason_bits.append(f"admin name: {cfgobj}")
                    if cfgobj in suspicious_admin_names:
                        reason_bits.append("admin name matches suspicious list")
                    if user in sso_users:
                        reason_bits.append(f"actor user IOC match: {user}")
                    findings.append(Finding(
                        rule_id="FORTI_LOCAL_ADMIN_ADD",
                        severity=sev,
                        reason="; ".join(reason_bits),
                        line_no=i,
                        raw=line,
                        fields=evt,
                    ))

    payload = {
        "tool": "zeid_data_CVE-2026-24858",
        "finding_count": len(findings),
        "findings": [asdict(x) for x in findings],
        "notes": {
            "default_iocs": {
                "sso_users": sorted(DEFAULT_SSO_USERS),
                "ip_iocs": sorted(DEFAULT_IP_IOCS),
                "suspicious_admin_names": sorted(DEFAULT_SUSPICIOUS_ADMIN_NAMES),
            },
            "tuning": "Use --extra-* flags to extend IOCs; edit defaults to fit your environment.",
        },
    }

    out_json = json.dumps(payload, indent=2, sort_keys=False)
    if args.out:
        Path(args.out).write_text(out_json, encoding="utf-8")
        print(f"[+] Wrote findings JSON: {args.out}")
    else:
        print(out_json)

    # Summary to stderr
    highs = sum(1 for x in findings if x.severity == "high")
    meds = sum(1 for x in findings if x.severity == "medium")
    lows = sum(1 for x in findings if x.severity == "low")
    print(f"[summary] Findings={len(findings)} high={highs} medium={meds} low={lows}", file=sys.stderr)

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
