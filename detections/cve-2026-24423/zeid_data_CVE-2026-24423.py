#!/usr/bin/env python3
"""zeid_data_CVE-2026-24423 â€” SmarterMail ConnectToHub unauth RCE detector (defensive-only)

Hunts for exploitation attempts against SmarterMail's ConnectToHub API by scanning:
  - Web access logs (IIS W3C or common/combined)
  - Optional SmarterMail admin/application logs (plain text)
  - Optional egress/proxy logs (plain text) to detect SmarterMail reaching hub setup endpoints

This tool does NOT exploit anything and does NOT modify systems.
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Dict, List, Optional, Tuple

TARGET_ENDPOINTS = [
    "/api/v1/settings/sysadmin/connect-to-hub",
]
HUB_SETUP_PATHS = [
    "/web/api/node-management/setup-initial-connection",
    "/web/api/hub-connection/setup-initial-connection",
]
APP_LOG_MARKERS = [
    "Connecting to hub",
    "connect-to-hub",
    "CommandMount",
    "SystemMount",
]

IIS_FIELDS_RE = re.compile(r"^#Fields:\s*(.*)$", re.IGNORECASE)
COMBINED_RE = re.compile(
    r'^(?P<ip>\S+)\s+\S+\s+\S+\s+\[(?P<time>[^\]]+)\]\s+"(?P<method>\S+)\s+(?P<uri>\S+)(?:\s+\S+)?"\s+(?P<status>\d+)'
)

@dataclass
class Finding:
    rule_id: str
    severity: str
    reason: str
    source: str
    line_no: int
    raw: str
    fields: Dict[str, str]

def load_text(path: Path) -> List[str]:
    return path.read_text(encoding="utf-8", errors="replace").splitlines()

def parse_iis_w3c(lines: List[str]) -> List[Dict[str, str]]:
    fields: Optional[List[str]] = None
    out: List[Dict[str, str]] = []
    for ln in lines:
        if ln.startswith("#"):
            m = IIS_FIELDS_RE.match(ln)
            if m:
                fields = m.group(1).split()
            continue
        if not ln.strip():
            continue
        if not fields:
            return []
        parts = ln.strip().split()
        if len(parts) < len(fields):
            continue
        out.append({fields[i]: parts[i] for i in range(len(fields))})
    return out

def normalize_uri(stem: str, query: str) -> str:
    if query and query != "-":
        return f"{stem}?{query}"
    return stem

def scan_uri(uri: str) -> List[Tuple[str, str, str]]:
    u = uri.lower()
    hits: List[Tuple[str, str, str]] = []
    if any(ep in u for ep in TARGET_ENDPOINTS):
        hits.append(("SMARTERMAIL_CONNECT_TO_HUB_REQUEST", "high", "Request to ConnectToHub endpoint"))
    if any(p in u for p in HUB_SETUP_PATHS):
        hits.append(("SMARTERMAIL_HUB_SETUP_PATH", "high", "Hub setup-initial-connection path observed"))
    if "hubaddress" in u:
        hits.append(("SMARTERMAIL_HUBADDRESS_PRESENT", "medium", "URI contains hubAddress parameter reference"))
    return hits

def scan_app_line(line: str) -> Optional[Tuple[str, str, str]]:
    low = line.lower()
    for m in APP_LOG_MARKERS:
        if m.lower() in low:
            sev = "high" if m.lower() in ("connecting to hub", "commandmount") else "medium"
            return ("SMARTERMAIL_APP_LOG_MARKER", sev, f"App log marker hit: {m}")
    return None

def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(
        prog="zeid_data_CVE-2026-24423",
        description="Detect SmarterMail ConnectToHub exploitation attempts for CVE-2026-24423 (defensive-only)."
    )
    ap.add_argument("--web-log", action="append", default=[], help="Web access log file. Repeatable.")
    ap.add_argument("--app-log", action="append", default=[], help="SmarterMail admin/app logs (plain text). Repeatable.")
    ap.add_argument("--egress-log", action="append", default=[], help="Egress/proxy logs (plain text). Repeatable.")
    ap.add_argument("--out", default="", help="Write JSON findings to this path (default: stdout).")
    args = ap.parse_args(argv)

    findings: List[Finding] = []

    # Web logs
    for lp in args.web_log:
        pth = Path(lp)
        if not pth.exists():
            print(f"[!] Missing web log: {pth}", file=sys.stderr)
            continue
        lines = load_text(pth)
        w3c = parse_iis_w3c(lines)
        if w3c:
            for idx, rec in enumerate(w3c, start=1):
                uri = normalize_uri(rec.get("cs-uri-stem", ""), rec.get("cs-uri-query", ""))
                for rule_id, sev, reason in scan_uri(uri):
                    fields = {
                        "c-ip": rec.get("c-ip",""),
                        "cs-method": rec.get("cs-method",""),
                        "uri": uri,
                        "sc-status": rec.get("sc-status",""),
                        "time": f"{rec.get('date','')} {rec.get('time','')}".strip(),
                    }
                    findings.append(Finding(rule_id, sev, reason, source=str(pth), line_no=idx, raw=lines[idx-1][:5000], fields=fields))
        else:
            for idx, line in enumerate(lines, start=1):
                m = COMBINED_RE.match(line)
                if m:
                    uri = m.group("uri")
                    for rule_id, sev, reason in scan_uri(uri):
                        fields = {"c-ip": m.group("ip"), "cs-method": m.group("method"), "uri": uri, "sc-status": m.group("status"), "time": m.group("time")}
                        findings.append(Finding(rule_id, sev, reason, source=str(pth), line_no=idx, raw=line[:5000], fields=fields))
                else:
                    for rule_id, sev, reason in scan_uri(line):
                        findings.append(Finding(rule_id, sev, reason, source=str(pth), line_no=idx, raw=line[:5000], fields={"uri_or_line": line[:2000]}))

    # App logs
    for lp in args.app_log:
        pth = Path(lp)
        if not pth.exists():
            print(f"[!] Missing app log: {pth}", file=sys.stderr)
            continue
        for idx, line in enumerate(load_text(pth), start=1):
            hit = scan_app_line(line)
            if hit:
                rule_id, sev, reason = hit
                findings.append(Finding(rule_id, sev, reason, source=str(pth), line_no=idx, raw=line[:5000], fields={}))

    # Egress logs
    for lp in args.egress_log:
        pth = Path(lp)
        if not pth.exists():
            print(f"[!] Missing egress log: {pth}", file=sys.stderr)
            continue
        for idx, line in enumerate(load_text(pth), start=1):
            for rule_id, sev, reason in scan_uri(line):
                if rule_id == "SMARTERMAIL_HUB_SETUP_PATH":
                    findings.append(Finding(rule_id, sev, reason, source=str(pth), line_no=idx, raw=line[:5000], fields={"line": line[:2000]}))

    payload = {
        "tool": "zeid_data_CVE-2026-24423",
        "finding_count": len(findings),
        "findings": [asdict(f) for f in findings],
        "notes": {"target_endpoints": TARGET_ENDPOINTS, "hub_setup_paths": HUB_SETUP_PATHS},
    }

    out_json = json.dumps(payload, indent=2, sort_keys=False)
    if args.out:
        Path(args.out).write_text(out_json, encoding="utf-8")
        print(f"[+] Wrote findings JSON: {args.out}")
    else:
        print(out_json)

    print(f"[summary] Findings={len(findings)}", file=sys.stderr)
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
