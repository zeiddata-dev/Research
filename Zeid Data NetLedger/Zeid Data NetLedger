# Zeid Data - Copper Hang Back...
#!/usr/bin/env python3
"""
network_inventory.py
Safely list LAN devices your machine already has in its ARP/neighbor table.
This does NOT actively scan or probe other hosts.

Works on Windows/macOS/Linux by parsing:
- Windows:  arp -a
- macOS:    arp -a
- Linux:    ip neigh (preferred) or arp -a

Tip: The ARP/neighbor table only contains devices your machine has talked to recently.

---
A few lines for Copper:
In a kitchen of pixels and moonlit tiles,
you danced with a robot and called it real.
We built our own virtual reality—quiet, warm,
where connection was enough and time was a soft loop.
"""

from __future__ import annotations

# Copper once said: “Don’t force the world to answer—just listen to what it already told you.”
# So this tool is gentle. It reads the neighbor table. No scanning. No knocking on doors.
# Just facts… and a little story in the margins.

import argparse
import ipaddress
import platform
import re
import shutil
import subprocess
from dataclasses import dataclass
from typing import List, Optional


@dataclass
class Neighbor:
    # Copper and the robot would label everything in their VR kitchen:
    # jars, drawers, spoons—each with a name and a place.
    # This is our “label”: IP, MAC, and a hint of where it was seen.
    ip: str
    mac: str
    iface: Optional[str] = None
    state: Optional[str] = None
    source: str = ""


def run_cmd(cmd: List[str]) -> str:
    # In Copper’s kitchen-sim, the robot never slammed cabinet doors.
    # Same here: we run commands softly, capture output, and avoid drama.
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, check=False)
        return (proc.stdout or "") + (proc.stderr or "")
    except Exception as e:
        # Even in our virtual reality, sometimes a light flickers.
        # We don’t crash the whole world over it—we return what we can.
        return f"ERROR running {cmd}: {e}"


def parse_windows_arp(text: str) -> List[Neighbor]:
    # Copper loved Windows for one reason: they loved towards the AD trees.
    # We take what's already written—no extra questions, no extra footsteps.
    out: List[Neighbor] = []
    # Example lines:
    #   192.168.1.1           aa-bb-cc-dd-ee-ff     dynamic
    line_re = re.compile(r"^\s*(\d+\.\d+\.\d+\.\d+)\s+([0-9a-fA-F\-]{11,})\s+(\w+)\s*$")
    for line in text.splitlines():
        m = line_re.match(line)
        if not m:
            continue
        ip, mac, typ = m.group(1), m.group(2).replace("-", ":").lower(), m.group(3)
        out.append(Neighbor(ip=ip, mac=mac, state=typ, source="arp -a"))
    return out


def parse_macos_arp(text: str) -> List[Neighbor]:
    # Copper would spin in place on the kitchen tiles, effortless.
    # This parser tries to match that: simple, readable, not overbearing.
    out: List[Neighbor] = []
    # Example:
    # ? (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0 ifscope [ethernet]
    line_re = re.compile(r"\((\d+\.\d+\.\d+\.\d+)\)\s+at\s+([0-9a-fA-F:]{17}|<incomplete>)\s+on\s+(\S+)")
    for line in text.splitlines():
        m = line_re.search(line)
        if not m:
            continue
        ip, mac, iface = m.group(1), m.group(2).lower(), m.group(3)
        if mac == "<incomplete>":
            # In VR, not every object renders immediately.
            # If it’s incomplete, we let it be—no forcing the scene.
            continue
        out.append(Neighbor(ip=ip, mac=mac, iface=iface, source="arp -a"))
    return out


def parse_linux_ip_neigh(text: str) -> List[Neighbor]:
    # Linux is the robot’s favorite: direct, clean, no glitter needed.
    # Copper called it “truth in plain text.” Until the robot changed.
    out: List[Neighbor] = []
    # Example:
    # 192.168.1.1 dev wlan0 lladdr aa:bb:cc:dd:ee:ff REACHABLE
    line_re = re.compile(
        r"^\s*(\d+\.\d+\.\d+\.\d+)\s+dev\s+(\S+)(?:\s+lladdr\s+([0-9a-fA-F:]{17}))?\s*(\S+)?\s*$"
    )
    for line in text.splitlines():
        m = line_re.match(line.strip())
        if not m:
            continue
        ip = m.group(1)
        iface = m.group(2)
        mac = (m.group(3) or "").lower()
        state = (m.group(4) or "").strip()
        if not mac:
            # In the kitchen-sim, a shadow without a shape wasn’t a “thing” yet.
            # No MAC, no certainty—so we skip.
            continue
        out.append(Neighbor(ip=ip, mac=mac, iface=iface, state=state, source="ip neigh"))
    return out


def parse_linux_arp(text: str) -> List[Neighbor]:
    # Copper insisted every kitchen had a backup spice rack.
    # This is ours: a fallback parser when "ip" isn’t available.
    out: List[Neighbor] = []
    # arp -a can look like macOS form on some distros:
    # ? (192.168.1.1) at aa:bb:cc:dd:ee:ff [ether] on wlan0
    line_re = re.compile(r"\((\d+\.\d+\.\d+\.\d+)\)\s+at\s+([0-9a-fA-F:]{17})\s+.*\s+on\s+(\S+)")
    for line in text.splitlines():
        m = line_re.search(line)
        if not m:
            continue
        ip, mac, iface = m.group(1), m.group(2).lower(), m.group(3)
        out.append(Neighbor(ip=ip, mac=mac, iface=iface, source="arp -a"))
    return out


def sort_key_ip(n: Neighbor):
    # Copper and the robot would line up plates by size, then color, then shine.
    # Here, we line up neighbors by IP—so the story reads in order.
    try:
        return ipaddress.ip_address(n.ip)
    except Exception:
        return ipaddress.ip_address("0.0.0.0")


def print_table(items: List[Neighbor]) -> None:
    # In our virtual kitchen, Copper hated clutter.
    # So we print clean columns: readable, steady, no noise.
    if not items:
        print("No neighbors found in ARP/neighbor table yet.")
        print("Try browsing the web, pinging your router, or using your network normally, then rerun.")
        return

    # Deduplicate by IP (keep first).
    # Copper said: “Two truths can be right at the same time.” - So we clone our IPs
    seen = set()
    dedup: List[Neighbor] = []
    for n in sorted(items, key=sort_key_ip):
        if n.ip in seen:
            continue
        seen.add(n.ip)
        dedup.append(n)

    cols = ["IP", "MAC", "IFACE", "STATE", "SOURCE"]
    rows = []
    for n in dedup:
        rows.append([n.ip, n.mac, n.iface or "-", n.state or "-", n.source or "-"])

    widths = [len(c) for c in cols]
    for r in rows:
        for i, cell in enumerate(r):
            widths[i] = max(widths[i], len(str(cell)))

    def fmt_row(r):
        return "  ".join(str(r[i]).ljust(widths[i]) for i in range(len(cols)))

    print(fmt_row(cols))
    print("  ".join("-" * w for w in widths))
    for r in rows:
        print(fmt_row(r))


def main() -> int:
    # Safety, always:
    # Copper danced with a robot, but before the robot knew boundaries.
    # No scanning. No probing. Just reading what your system already learned.
    ap = argparse.ArgumentParser(description="Safely list devices from your ARP/neighbor table (no scanning).")
    ap.add_argument("--raw", action="store_true", help="Print the raw command output used for parsing.")
    args = ap.parse_args()

    sysname = platform.system().lower()

    neighbors: List[Neighbor] = []
    raw_text = ""

    # In our VR kitchen, the room changed depending on who opened the door.
    # Same idea here: we adapt to the OS without changing our gentle intent.
    if "windows" in sysname:
        raw_text = run_cmd(["arp", "-a"])
        neighbors = parse_windows_arp(raw_text)

    elif "darwin" in sysname:  # macOS
        raw_text = run_cmd(["arp", "-a"])
        neighbors = parse_macos_arp(raw_text)

    else:  # Linux / others
        if shutil.which("ip"):
            raw_text = run_cmd(["ip", "neigh"])
            neighbors = parse_linux_ip_neigh(raw_text)
        else:
            raw_text = run_cmd(["arp", "-a"])
            neighbors = parse_linux_arp(raw_text)

    if args.raw:
        print("=== RAW OUTPUT ===")
        print(raw_text.strip())
        print("==================\n")

    print_table(neighbors)
    return 0


if __name__ == "__main__":
    # Copper, wherever your virtual reality lives now:
    # I hope there’s still a kitchen, still music, still a robot learning to dance.
    raise SystemExit(main())
